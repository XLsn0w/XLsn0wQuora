
#import <UIKit/UIKit.h>

@interface WXPullView : UIView

- (void)animationWith:(CGFloat)y;

@end
/*.
 
 一个程序占有的内存分为5类：
 
 1. 全局/静态数据区---->对应  .data数据段
 
 2.常量数据区--> .rdata只读数据段
 
 3.代码区--->  .text代码段 (存储代码)
 
 4.栈
 
 5.堆
 
 
 
 
 
 内存存储情况:
 
 1. 全局/静态数据区---> 全局/静态数据
 
 2.常量数据区(.rdata)-->常量字符串
 
 3.栈---->自动变量或者局部变量，以及传递的函数参数
 
 4.堆--->用户控制  new/malloc出来的内存，注意内存泄露问题
 
 
 
 
 
 
 栈区是先进后出，队列是先进先出。
 
 栈区就相当于玻璃杯，往玻璃杯里放奥利奥，第一块放入的奥利奥，肯定是最后一个拿出来。
 
 队列就相当于掉了底的玻璃杯，最先放入的，必定最先掉出来。
 
 网上有个更绝的比喻：队列是吃多了拉，栈区是吃多了吐。
 
 这里解析的是栈区和堆区的内存问题，说到了栈区自然引出队列，捎带提一笔。
 
 言归正传，以下面这个非常简单的C语言程序为例：
 
 
 
 变量 i 和 j 就是保存在栈区里的
 
 有一句话如是说：在OC中，默认不带*号的都是保存在栈区的。
 
 在这里，变量名其实就是变量保存在栈区的内存地址的别名。
 
 那么，这个程序运行时在栈区是如何出入的呢？
 
 程序在栈区的出入步骤：
 
 程序运行执行main函数，i首先进入栈区，位于最底部。然后j进入栈区，printf调用函数sum(i, j)紧随其后进入栈区。
 
 函数sum(int x, int y)中的参数，从右到左依次进入栈区。先是y再是x。
 
 栈区存储样式：
 
 
 当程序运行结束后，栈区内的所有元素会从上到下的依次出栈，栈会恢复到原始状态。
 
 栈的先进后出方式，会特别整齐的存取，不会产生内存碎片。
 
 
 
 现在加入线程概念：每条主线程为1M内存，每条子线程为512K内存
 
 每个线程都会对应一个栈区！
 
 当程序开展了多条线程的时候，每个线程都会开辟一块栈区，如下图所示：
 
 
 当线程执行完毕之后，各个线程栈区会依次清除掉。
 
 所以：对于系统来说，给线程分配栈区内存只需要分配512kb的倍数即可，
 
 分配出来的这块内存空间作为多线程整体的栈区，来管理多线程。
 
 如此一来，内存会被管理的井井有条，速度飞快。
 
 
 堆区
 
 堆区是由系统通过链表管理维护的，所有应用程序共享的一块内存空间。包括内存+虚拟内存（磁盘缓存）
 
 程序运行时堆区的内部操作，以及引发内存泄漏的原因：
 
 创建一个新的对象时，对象p指针存放在栈区，p将指向在堆区开辟的一块存储空间Person
 
 
 在程序结束之前，p对象必须release，不然系统不知道释放堆区的Person内存。
 
 如果p对象没有release，只是p＝nil; 就是p指针指向了堆区地址为0的地方，那么原来的Person永远无法再次访问，而且也无法释放掉。
 
 堆是所有程序共享的内存，当N个这样的内存得不到释放，堆区会被挤爆，程序立马瘫痪。这就是内存泄漏。
 
 这里要知道的是：系统在堆区只会记录某一个区域被使用了，并不会管你是什么类型的（匿名访问）。
 
 我写了一段对象与堆区的对话，来说明这个现象：
 
 某程序的对象p：喂！堆！我有个Person，你给我记录一下。
 
 堆：尼玛，今天我碰到了N个Person了，别瞎掰活，直接说要多大空间！
 
 p：100kb
 
 堆：已开辟。
 
 堆就跟小旅馆一样，我管你是男女老幼，直接说要什么价位的房子。
 
 那么，既然是匿名访问，堆不管你的类型了，那怎么区分这块内存是什么类型的呢？
 
 简单：什么类型指向这块内存，这块内存就是什么类型的。
 
 程序示例：
 
 定义一个Person类
 
 
 
 在main.m文件中利用Person类创建一个对象，这个对象即便是定义为NSString类型，在编译的时候也不会报错，会有警告
 
 
 这就说明：堆中开辟的内存自身并不强调类型，而是受到栈区中对象类型的左右。
 
 */
